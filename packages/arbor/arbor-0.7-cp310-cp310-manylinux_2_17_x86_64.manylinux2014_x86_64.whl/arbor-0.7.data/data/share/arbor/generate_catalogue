#!/usr/bin/env python3

# Note: compatible with Python2.7 and Python3.

from __future__ import print_function
import sys
import string
import argparse

def parse_arguments():
    def append_slash(s):
        return s+'/' if s and not s.endswith('/') else s

    class ConciseHelpFormatter(argparse.HelpFormatter):
        def __init__(self, **kwargs):
            super(ConciseHelpFormatter, self).__init__(max_help_position=20, **kwargs)

        def _format_action_invocation(self, action):
            if not action.option_strings:
                return super(ConciseHelpFormatter, self)._format_action_invocation(action)
            else:
                optstr = ', '.join(action.option_strings)
                if action.nargs==0:
                    return optstr
                else:
                    return optstr+' '+self._format_args(action, action.dest.upper())

    parser = argparse.ArgumentParser(
        description = 'Generate global default catalogue source for Arbor build.',
        usage = '%(prog)s [options] [module...]',
        add_help = False,
        formatter_class = ConciseHelpFormatter)

    parser.add_argument(
        'modules',
        nargs = '*',
        help = argparse.SUPPRESS)

    group = parser.add_argument_group('Options')

    group.add_argument(
        '-I', '--module-prefix',
        default = 'mechanisms',
        metavar = 'PATH',
        dest = 'modpfx',
        type = append_slash,
        help = 'directory prefix for module includes, default "%(default)s"')

    group.add_argument(
        '-A', '--arbor-prefix',
        default = '',
        metavar = 'PATH',
        dest = 'arbpfx',
        type = append_slash,
        help = 'directory prefix for arbor includes, default "%(default)s"')

    group.add_argument(
        '-B', '--backend',
        default = [],
        action = 'append',
        dest = 'backends',
        metavar = 'BACKEND',
        help = 'register implementations for back-end %(metavar)s')

    group.add_argument(
        '-N', '--namespace',
        default = [],
        action = 'append',
        dest = 'namespaces',
        metavar = 'NAMESPACE',
        help = 'add %(metavar)s to list of implicitly included namespaces')

    group.add_argument(
        '-C', '--catalogue',
        default = 'default',
        dest = 'catalogue',
        help = 'catalogue name, default "%(default)s"')

    group.add_argument(
        '-o', '--output',
        default = [],
        dest = 'output',
        metavar = 'FILE',
        help = 'save output to %(metavar)s (default is to print to stdout)')

    group.add_argument(
        '-h', '--help',
        action = 'help',
        help = 'display this help and exit')

    return vars(parser.parse_args())


def generate(catalogue, modpfx='', arbpfx='', modules=[], backends=[], namespaces=[], **rest):
    src = string.Template(\
r'''// Automatically generated by:
// $cmdline

#include <${arbpfx}mechanism_abi.h>

$module_includes

#ifdef STANDALONE
extern "C" {
    [[gnu::visibility("default")]] const void* get_catalogue(int* n) {
        static arb_mechanism cat[${n_modules}] = {
            ${insert_modules}
        };
        *n = ${n_modules};
        return (void*)cat;
    }
}
#else

#include <${arbpfx}mechcat.hpp>
#include <${arbpfx}mechanism.hpp>
#include <${arbpfx}assert.hpp>

namespace arb {
mechanism_catalogue build_${catalogue}_catalogue() {
    mechanism_catalogue cat;

#define ADD(make) do {                                                                  \
    auto mech = make();                                                                 \
    auto ty = mech.type();                                                              \
    auto nm = ty.name;                                                                  \
    auto ig = mech.i_gpu();                                                             \
    auto ic = mech.i_cpu();                                                             \
    arb_assert(ic || ig);                                                               \
    cat.add(nm, ty);                                                                    \
    if (ic) cat.register_implementation(nm, std::make_unique<arb::mechanism>(ty, *ic)); \
    if (ig) cat.register_implementation(nm, std::make_unique<arb::mechanism>(ty, *ig)); \
} while (false)

    $add_modules

#undef ADD

    return cat;
}

ARB_ARBOR_API const mechanism_catalogue& global_${catalogue}_catalogue() {
    static mechanism_catalogue cat = build_${catalogue}_catalogue();
    return cat;
}
} // namespace arb
#endif
''')

    def indent(n, lines):
        return '{{:<{0!s}}}'.format(n+1).format('\n').join(lines)

    return src.safe_substitute(dict(
        cmdline=" ".join(sys.argv),
        arbpfx=arbpfx,
        catalogue=catalogue,
        module_includes=indent(0,
            ['#include "{}{}.hpp"'.format(modpfx, m) for m in modules]),
        add_modules=indent(4, [f'ADD(make_arb_{catalogue}_catalogue_{mod});' for mod in modules]),
        n_modules=len(modules),
        insert_modules=indent(12, [f'make_arb_{catalogue}_catalogue_{mod}(),' for mod in modules]),
        ))


args = parse_arguments()
code = generate(**args)
if args['output']:
    print(code, file = open(args['output'],'w'))
else:
    print(code)
