{"version":3,"file":"chunks/app_views_organizationStats_types_tsx-app_views_organizationStats_usageChart_index_tsx.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/views/organizationStats/types.tsx","webpack:///./app/views/organizationStats/usageChart/index.tsx","webpack:///./app/views/organizationStats/usageChart/utils.tsx","webpack:///./app/views/organizationStats/utils.tsx"],"sourcesContent":["import {SeriesApi} from 'sentry/types';\n\nexport enum Outcome {\n  ACCEPTED = 'accepted',\n  FILTERED = 'filtered',\n  INVALID = 'invalid',\n  DROPPED = 'dropped', // this is not a real outcome coming from the server\n  RATE_LIMITED = 'rate_limited',\n  CLIENT_DISCARD = 'client_discard',\n}\n\n/**\n * Raw response from API endpoint\n */\nexport type UsageSeries = SeriesApi & {\n  end: string;\n  start: string;\n};\n\nexport type UsageStat = {\n  accepted: number;\n  date: string;\n  dropped: {\n    total: number;\n    other?: number;\n  };\n  filtered: number;\n  total: number;\n};\n","import {Component, Fragment} from 'react';\nimport {withTheme} from '@emotion/react';\nimport styled from '@emotion/styled';\nimport Color from 'color';\nimport type {SeriesOption, TooltipComponentOption} from 'echarts';\n\nimport BaseChart from 'sentry/components/charts/baseChart';\nimport Legend from 'sentry/components/charts/components/legend';\nimport xAxis from 'sentry/components/charts/components/xAxis';\nimport barSeries from 'sentry/components/charts/series/barSeries';\nimport {ChartContainer, HeaderTitleLegend} from 'sentry/components/charts/styles';\nimport LoadingIndicator from 'sentry/components/loadingIndicator';\nimport Panel from 'sentry/components/panels/panel';\nimport Placeholder from 'sentry/components/placeholder';\nimport {DATA_CATEGORY_NAMES} from 'sentry/constants';\nimport {IconWarning} from 'sentry/icons';\nimport {t} from 'sentry/locale';\nimport space from 'sentry/styles/space';\nimport {DataCategory, IntervalPeriod, SelectValue} from 'sentry/types';\nimport {parsePeriodToHours, statsPeriodToDays} from 'sentry/utils/dates';\nimport getDynamicText from 'sentry/utils/getDynamicText';\nimport commonTheme, {Theme} from 'sentry/utils/theme';\n\nimport {formatUsageWithUnits, GIGABYTE} from '../utils';\n\nimport {getTooltipFormatter, getXAxisDates, getXAxisLabelInterval} from './utils';\n\ntype ChartProps = React.ComponentProps<typeof BaseChart>;\n\nconst COLOR_ERRORS = Color(commonTheme.dataCategory.errors).lighten(0.25).string();\nexport const COLOR_TRANSACTIONS = Color(commonTheme.dataCategory.transactions)\n  .lighten(0.35)\n  .string();\nconst COLOR_ATTACHMENTS = Color(commonTheme.dataCategory.attachments)\n  .lighten(0.65)\n  .string();\n\nexport const COLOR_DROPPED = commonTheme.red300;\nconst COLOR_FILTERED = commonTheme.pink100;\n\nexport type CategoryOption = {\n  /**\n   * Scale of y-axis with no usage data.\n   */\n  yAxisMinInterval: number;\n} & SelectValue<DataCategory>;\n\nexport const CHART_OPTIONS_DATACATEGORY: CategoryOption[] = [\n  {\n    label: DATA_CATEGORY_NAMES[DataCategory.ERRORS],\n    value: DataCategory.ERRORS,\n    disabled: false,\n    yAxisMinInterval: 100,\n  },\n  {\n    label: DATA_CATEGORY_NAMES[DataCategory.TRANSACTIONS],\n    value: DataCategory.TRANSACTIONS,\n    disabled: false,\n    yAxisMinInterval: 100,\n  },\n  {\n    label: DATA_CATEGORY_NAMES[DataCategory.ATTACHMENTS],\n    value: DataCategory.ATTACHMENTS,\n    disabled: false,\n    yAxisMinInterval: 0.5 * GIGABYTE,\n  },\n];\n\nexport enum ChartDataTransform {\n  CUMULATIVE = 'cumulative',\n  PERIODIC = 'periodic',\n}\n\nexport const CHART_OPTIONS_DATA_TRANSFORM: SelectValue<ChartDataTransform>[] = [\n  {\n    label: t('Cumulative'),\n    value: ChartDataTransform.CUMULATIVE,\n    disabled: false,\n  },\n  {\n    label: t('Periodic'),\n    value: ChartDataTransform.PERIODIC,\n    disabled: false,\n  },\n];\n\nexport enum SeriesTypes {\n  ACCEPTED = 'Accepted',\n  DROPPED = 'Dropped',\n  PROJECTED = 'Projected',\n  FILTERED = 'Filtered',\n}\n\ntype DefaultProps = {\n  /**\n   * Config for category dropdown options\n   */\n  categoryOptions: CategoryOption[];\n  /**\n   * Modify the usageStats using the transformation method selected.\n   * 1. This must be a pure function!\n   * 2. If the parent component will handle the data transformation, you should\n   *    replace this prop with \"(s) => {return s}\"\n   */\n  handleDataTransformation: (\n    stats: ChartStats,\n    transform: ChartDataTransform\n  ) => ChartStats;\n\n  /**\n   * Intervals between the x-axis values\n   */\n  usageDateInterval: IntervalPeriod;\n\n  /**\n   * Display datetime in UTC\n   */\n  usageDateShowUtc: boolean;\n};\n\ntype Props = DefaultProps & {\n  dataCategory: DataCategory;\n\n  dataTransform: ChartDataTransform;\n  theme: Theme;\n  usageDateEnd: string;\n\n  usageDateStart: string;\n  /**\n   * Usage data to draw on chart\n   */\n  usageStats: ChartStats;\n\n  /**\n   * Additional data to draw on the chart alongside usage\n   */\n  chartSeries?: SeriesOption[];\n  /**\n   * Replace default tooltip\n   */\n  chartTooltip?: TooltipComponentOption;\n\n  errors?: Record<string, Error>;\n  footer?: React.ReactNode;\n\n  isError?: boolean;\n\n  isLoading?: boolean;\n\n  title?: React.ReactNode;\n};\n\ntype State = {\n  xAxisDates: string[];\n};\n\nexport type ChartStats = {\n  accepted: NonNullable<SeriesOption['data']>;\n  dropped: NonNullable<SeriesOption['data']>;\n  projected: NonNullable<SeriesOption['data']>;\n  filtered?: NonNullable<SeriesOption['data']>;\n};\n\nexport class UsageChart extends Component<Props, State> {\n  static defaultProps: DefaultProps = {\n    categoryOptions: CHART_OPTIONS_DATACATEGORY,\n    usageDateShowUtc: true,\n    usageDateInterval: '1d',\n    handleDataTransformation: (stats, transform) => {\n      const chartData: ChartStats = {\n        accepted: [],\n        dropped: [],\n        projected: [],\n        filtered: [],\n      };\n      const isCumulative = transform === ChartDataTransform.CUMULATIVE;\n\n      Object.keys(stats).forEach(k => {\n        let count = 0;\n\n        chartData[k] = stats[k].map(stat => {\n          const [x, y] = stat.value;\n          count = isCumulative ? count + y : y;\n\n          return {\n            ...stat,\n            value: [x, count],\n          };\n        });\n      });\n\n      return chartData;\n    },\n  };\n\n  state: State = {\n    xAxisDates: [],\n  };\n\n  /**\n   * UsageChart needs to generate the X-Axis dates as props.usageStats may\n   * not pass the complete range of X-Axis data points\n   *\n   * E.g. usageStats.accepted covers day 1-15 of a month, usageStats.projected\n   * either covers day 16-30 or may not be available at all.\n   */\n  static getDerivedStateFromProps(nextProps: Readonly<Props>, prevState: State): State {\n    const {usageDateStart, usageDateEnd, usageDateShowUtc, usageDateInterval} = nextProps;\n\n    return {\n      ...prevState,\n      xAxisDates: getXAxisDates(\n        usageDateStart,\n        usageDateEnd,\n        usageDateShowUtc,\n        usageDateInterval\n      ),\n    };\n  }\n\n  get chartColors() {\n    const {dataCategory, theme} = this.props;\n    const COLOR_PROJECTED = theme.chartOther;\n\n    if (dataCategory === DataCategory.ERRORS) {\n      return [COLOR_ERRORS, COLOR_FILTERED, COLOR_DROPPED, COLOR_PROJECTED];\n    }\n\n    if (dataCategory === DataCategory.ATTACHMENTS) {\n      return [COLOR_ATTACHMENTS, COLOR_FILTERED, COLOR_DROPPED, COLOR_PROJECTED];\n    }\n\n    return [COLOR_TRANSACTIONS, COLOR_FILTERED, COLOR_DROPPED, COLOR_PROJECTED];\n  }\n\n  get chartMetadata(): {\n    chartData: ChartStats;\n    chartLabel: React.ReactNode;\n    tooltipValueFormatter: (val?: number) => string;\n    xAxisData: string[];\n    xAxisLabelInterval: number;\n    xAxisTickInterval: number;\n    yAxisFormatter: (val: number) => string;\n    yAxisMinInterval: number;\n  } {\n    const {categoryOptions, usageDateStart, usageDateEnd} = this.props;\n    const {\n      usageDateInterval,\n      usageStats,\n      dataCategory,\n      dataTransform,\n      handleDataTransformation,\n    } = this.props;\n    const {xAxisDates} = this.state;\n\n    const selectDataCategory = categoryOptions.find(o => o.value === dataCategory);\n    if (!selectDataCategory) {\n      throw new Error('Selected item is not supported');\n    }\n\n    // Do not assume that handleDataTransformation is a pure function\n    const chartData: ChartStats = {\n      ...handleDataTransformation(usageStats, dataTransform),\n    };\n\n    Object.keys(chartData).forEach(k => {\n      const isProjected = k === SeriesTypes.PROJECTED;\n\n      // Map the array and destructure elements to avoid side-effects\n      chartData[k] = chartData[k].map(stat => {\n        return {\n          ...stat,\n          tooltip: {show: false},\n          itemStyle: {opacity: isProjected ? 0.6 : 1},\n        };\n      });\n    });\n\n    // Use hours as common units\n    const dataPeriod = statsPeriodToDays(undefined, usageDateStart, usageDateEnd) * 24;\n    const barPeriod = parsePeriodToHours(usageDateInterval);\n    if (dataPeriod < 0 || barPeriod < 0) {\n      throw new Error('UsageChart: Unable to parse data time period');\n    }\n\n    const {xAxisTickInterval, xAxisLabelInterval} = getXAxisLabelInterval(\n      dataPeriod,\n      dataPeriod / barPeriod\n    );\n\n    const {label, yAxisMinInterval} = selectDataCategory;\n\n    return {\n      chartLabel: label,\n      chartData,\n      xAxisData: xAxisDates,\n      xAxisTickInterval,\n      xAxisLabelInterval,\n      yAxisMinInterval,\n      yAxisFormatter: (val: number) =>\n        formatUsageWithUnits(val, dataCategory, {\n          isAbbreviated: true,\n          useUnitScaling: true,\n        }),\n      tooltipValueFormatter: getTooltipFormatter(dataCategory),\n    };\n  }\n\n  get chartSeries() {\n    const {chartSeries} = this.props;\n    const {chartData} = this.chartMetadata;\n\n    let series: SeriesOption[] = [\n      barSeries({\n        name: SeriesTypes.ACCEPTED,\n        data: chartData.accepted as any, // TODO(ts)\n        barMinHeight: 1,\n        stack: 'usage',\n        legendHoverLink: false,\n      }),\n      barSeries({\n        name: SeriesTypes.FILTERED,\n        data: chartData.filtered as any, // TODO(ts)\n        barMinHeight: 1,\n        stack: 'usage',\n        legendHoverLink: false,\n      }),\n      barSeries({\n        name: SeriesTypes.DROPPED,\n        data: chartData.dropped as any, // TODO(ts)\n        stack: 'usage',\n        legendHoverLink: false,\n      }),\n      barSeries({\n        name: SeriesTypes.PROJECTED,\n        data: chartData.projected as any, // TODO(ts)\n        barMinHeight: 1,\n        stack: 'usage',\n        legendHoverLink: false,\n      }),\n    ];\n\n    // Additional series passed by parent component\n    if (chartSeries) {\n      series = series.concat(chartSeries as SeriesOption[]);\n    }\n\n    return series;\n  }\n\n  get chartLegend() {\n    const {chartData} = this.chartMetadata;\n    const legend = [\n      {\n        name: SeriesTypes.ACCEPTED,\n      },\n    ];\n\n    if (chartData.filtered && (chartData.filtered as any[]).length > 0) {\n      legend.push({\n        name: SeriesTypes.FILTERED,\n      });\n    }\n\n    if ((chartData.dropped as any[]).length > 0) {\n      legend.push({\n        name: SeriesTypes.DROPPED,\n      });\n    }\n\n    if ((chartData.projected as any[]).length > 0) {\n      legend.push({\n        name: SeriesTypes.PROJECTED,\n      });\n    }\n    return legend;\n  }\n\n  get chartTooltip(): ChartProps['tooltip'] {\n    const {chartTooltip} = this.props;\n\n    if (chartTooltip) {\n      return chartTooltip;\n    }\n\n    const {tooltipValueFormatter} = this.chartMetadata;\n\n    return {\n      // Trigger to axis prevents tooltip from redrawing when hovering\n      // over individual bars\n      trigger: 'axis',\n      valueFormatter: tooltipValueFormatter,\n    };\n  }\n\n  renderChart() {\n    const {theme, title, isLoading, isError, errors} = this.props;\n    if (isLoading) {\n      return (\n        <Placeholder height=\"200px\">\n          <LoadingIndicator mini />\n        </Placeholder>\n      );\n    }\n\n    if (isError) {\n      return (\n        <Placeholder height=\"200px\">\n          <IconWarning size={theme.fontSizeExtraLarge} />\n          <ErrorMessages>\n            {errors &&\n              Object.keys(errors).map(k => <span key={k}>{errors[k]?.message}</span>)}\n          </ErrorMessages>\n        </Placeholder>\n      );\n    }\n\n    const {\n      xAxisData,\n      xAxisTickInterval,\n      xAxisLabelInterval,\n      yAxisMinInterval,\n      yAxisFormatter,\n    } = this.chartMetadata;\n\n    return (\n      <Fragment>\n        <HeaderTitleLegend>{title || t('Current Usage Period')}</HeaderTitleLegend>\n        {getDynamicText({\n          value: (\n            <BaseChart\n              colors={this.chartColors}\n              grid={{bottom: '3px', left: '0px', right: '10px', top: '40px'}}\n              xAxis={xAxis({\n                show: true,\n                type: 'category',\n                name: 'Date',\n                data: xAxisData,\n                axisTick: {\n                  interval: xAxisTickInterval,\n                  alignWithLabel: true,\n                },\n                axisLabel: {\n                  interval: xAxisLabelInterval,\n                  formatter: (label: string) => label.slice(0, 6), // Limit label to 6 chars\n                },\n                theme,\n              })}\n              yAxis={{\n                min: 0,\n                minInterval: yAxisMinInterval,\n                axisLabel: {\n                  formatter: yAxisFormatter,\n                  color: theme.chartLabel,\n                },\n              }}\n              series={this.chartSeries}\n              tooltip={this.chartTooltip}\n              onLegendSelectChanged={() => {}}\n              legend={Legend({\n                right: 10,\n                top: 5,\n                data: this.chartLegend,\n                theme,\n              })}\n            />\n          ),\n          fixed: <Placeholder height=\"200px\" />,\n        })}\n      </Fragment>\n    );\n  }\n\n  render() {\n    const {footer} = this.props;\n\n    return (\n      <Panel id=\"usage-chart\">\n        <ChartContainer>{this.renderChart()}</ChartContainer>\n        {footer}\n      </Panel>\n    );\n  }\n}\n\nexport default withTheme(UsageChart);\n\nconst ErrorMessages = styled('div')`\n  display: flex;\n  flex-direction: column;\n\n  margin-top: ${space(1)};\n  font-size: ${p => p.theme.fontSizeSmall};\n`;\n","import moment from 'moment';\n\nimport {parseStatsPeriod} from 'sentry/components/organizations/pageFilters/parse';\nimport {DataCategory, IntervalPeriod} from 'sentry/types';\nimport {parsePeriodToHours} from 'sentry/utils/dates';\n\nimport {formatUsageWithUnits} from '../utils';\n\n/**\n * Avoid changing \"MMM D\" format as X-axis labels on UsageChart are naively\n * truncated by date.slice(0, 6). This avoids \"...\" when truncating by ECharts.\n */\nexport const FORMAT_DATETIME_DAILY = 'MMM D';\nexport const FORMAT_DATETIME_HOURLY = 'MMM D LT';\n\n/**\n * Used to generate X-axis data points and labels for UsageChart\n * Ensure that this method is idempotent and doesn't change the moment object\n * that is passed in\n *\n * Use the `useUtc` parameter to get the UTC date for the provided\n * moment instance.\n */\nexport function getDateFromMoment(\n  m: moment.Moment,\n  interval: IntervalPeriod = '1d',\n  useUtc: boolean = false\n) {\n  const days = parsePeriodToHours(interval) / 24;\n  if (days >= 1) {\n    return useUtc\n      ? moment.utc(m).format(FORMAT_DATETIME_DAILY)\n      : m.format(FORMAT_DATETIME_DAILY);\n  }\n\n  const parsedInterval = parseStatsPeriod(interval);\n  const datetime = useUtc ? moment(m).utc() : moment(m).local();\n\n  return parsedInterval\n    ? `${datetime.format(FORMAT_DATETIME_HOURLY)} - ${datetime\n        .add(parsedInterval.period as any, parsedInterval.periodLength as any)\n        .format('LT (Z)')}`\n    : datetime.format(FORMAT_DATETIME_HOURLY);\n}\n\nexport function getDateFromUnixTimestamp(timestamp: number) {\n  const date = moment.unix(timestamp);\n  return getDateFromMoment(date);\n}\n\nexport function getXAxisDates(\n  dateStart: string,\n  dateEnd: string,\n  dateUtc: boolean = false,\n  interval: IntervalPeriod = '1d'\n): string[] {\n  const range: string[] = [];\n  const start = moment(dateStart).startOf('h');\n  const end = moment(dateEnd).startOf('h');\n\n  if (!start.isValid() || !end.isValid()) {\n    return range;\n  }\n\n  const {period, periodLength} = parseStatsPeriod(interval) ?? {\n    period: 1,\n    periodLength: 'd',\n  };\n\n  while (!start.isAfter(end)) {\n    range.push(getDateFromMoment(start, interval, dateUtc));\n    start.add(period as any, periodLength as any); // FIXME(ts): Something odd with momentjs types\n  }\n\n  return range;\n}\n\nexport function getTooltipFormatter(dataCategory: DataCategory) {\n  return (val: number = 0) =>\n    formatUsageWithUnits(val, dataCategory, {useUnitScaling: true});\n}\n\nconst MAX_NUMBER_OF_LABELS = 10;\n\n/**\n *\n * @param dataPeriod - Quantity of hours covered by the data\n * @param numBars - Quantity of data points covered by the dataPeriod\n */\nexport function getXAxisLabelInterval(dataPeriod: number, numBars: number) {\n  return dataPeriod > 7 * 24\n    ? getLabelIntervalLongPeriod(dataPeriod, numBars)\n    : getLabelIntervalShortPeriod(dataPeriod, numBars);\n}\n\n/**\n * @param dataPeriod - Quantity of hours covered by data, expected 7+ days\n */\nfunction getLabelIntervalLongPeriod(dataPeriod: number, numBars: number) {\n  const days = dataPeriod / 24;\n  if (days <= 7) {\n    throw new Error('This method should be used for periods > 7 days');\n  }\n\n  // Use 1 tick per day\n  let numTicks = days;\n  let numLabels = numTicks;\n\n  const daysBetweenLabels = [2, 4, 7, 14];\n  const daysBetweenTicks = [1, 2, 7, 7];\n\n  for (let i = 0; i < daysBetweenLabels.length && numLabels > MAX_NUMBER_OF_LABELS; i++) {\n    numLabels = numTicks / daysBetweenLabels[i];\n    numTicks = days / daysBetweenTicks[i];\n  }\n\n  return {\n    xAxisTickInterval: numBars / numTicks - 1,\n    xAxisLabelInterval: numBars / numLabels - 1,\n  };\n}\n\n/**\n * @param dataPeriod - Quantity of hours covered by data, expected <7 days\n */\nfunction getLabelIntervalShortPeriod(dataPeriod: number, numBars: number) {\n  const days = dataPeriod / 24;\n  if (days > 7) {\n    throw new Error('This method should be used for periods <= 7 days');\n  }\n\n  // Use 1 tick/label per day, since it's guaranteed to be 7 or less\n  const numTicks = days;\n  const interval = numBars / numTicks;\n\n  return {\n    xAxisTickInterval: interval - 1,\n    xAxisLabelInterval: interval - 1,\n  };\n}\n","import {DateTimeObject, getSeriesApiInterval} from 'sentry/components/charts/utils';\nimport {DataCategory} from 'sentry/types';\nimport {formatBytesBase10} from 'sentry/utils';\nimport {parsePeriodToHours} from 'sentry/utils/dates';\n\nexport const MILLION = 10 ** 6;\nexport const BILLION = 10 ** 9;\nexport const GIGABYTE = 10 ** 9;\n\ntype FormatOptions = {\n  /**\n   * Truncate 1234 => 1.2k or 1,234,000 to 1.23M\n   */\n  isAbbreviated?: boolean;\n\n  /**\n   * Convert attachments to use the most appropriate unit KB/MB/GB/TB/etc.\n   * Otherwise, it will default to GB\n   */\n  useUnitScaling?: boolean;\n};\n\n/**\n * This expects usage values/quantities for the data categories that we sell.\n *\n * Note: usageQuantity for Attachments should be in BYTES\n */\nexport function formatUsageWithUnits(\n  usageQuantity: number = 0,\n  dataCategory: DataCategory,\n  options: FormatOptions = {isAbbreviated: false, useUnitScaling: false}\n) {\n  if (dataCategory !== DataCategory.ATTACHMENTS) {\n    return options.isAbbreviated\n      ? abbreviateUsageNumber(usageQuantity)\n      : usageQuantity.toLocaleString();\n  }\n\n  if (options.useUnitScaling) {\n    return formatBytesBase10(usageQuantity);\n  }\n\n  const usageGb = usageQuantity / GIGABYTE;\n  return options.isAbbreviated\n    ? `${abbreviateUsageNumber(usageGb)} GB`\n    : `${usageGb.toLocaleString(undefined, {maximumFractionDigits: 2})} GB`;\n}\n\n/**\n * Good default for \"formatUsageWithUnits\"\n */\nexport function getFormatUsageOptions(dataCategory: DataCategory): FormatOptions {\n  return {\n    isAbbreviated: dataCategory !== DataCategory.ATTACHMENTS,\n    useUnitScaling: dataCategory === DataCategory.ATTACHMENTS,\n  };\n}\n\n/**\n * Instead of using this function directly, use formatReservedWithUnits or\n * formatUsageWithUnits with options.isAbbreviated to true instead.\n *\n * This function display different precision for billion/million/thousand to\n * provide clarity on usage of errors/transactions/attachments to the user.\n *\n * If you are not displaying usage numbers, it might be better to use\n * `formatAbbreviatedNumber` in 'sentry/utils/formatters'\n */\nexport function abbreviateUsageNumber(n: number) {\n  if (n >= BILLION) {\n    return (n / BILLION).toLocaleString(undefined, {maximumFractionDigits: 2}) + 'B';\n  }\n\n  if (n >= MILLION) {\n    return (n / MILLION).toLocaleString(undefined, {maximumFractionDigits: 1}) + 'M';\n  }\n\n  if (n >= 1000) {\n    return (n / 1000).toFixed().toLocaleString() + 'K';\n  }\n\n  // Do not show decimals\n  return n.toFixed().toLocaleString();\n}\n\n/**\n * We want to display datetime in UTC in the following situations:\n *\n * 1) The user selected an absolute date range with UTC\n * 2) The user selected a wide date range with 1d interval\n *\n * When the interval is 1d, we need to use UTC because the 24 hour range might\n * shift forward/backward depending on the user's timezone, or it might be\n * displayed as a day earlier/later\n */\nexport function isDisplayUtc(datetime: DateTimeObject): boolean {\n  if (datetime.utc) {\n    return true;\n  }\n\n  const interval = getSeriesApiInterval(datetime);\n  const hours = parsePeriodToHours(interval);\n  return hours >= 24;\n}\n"],"names":["Outcome","COLOR_ERRORS","Color","commonTheme","lighten","string","COLOR_TRANSACTIONS","COLOR_ATTACHMENTS","COLOR_DROPPED","COLOR_FILTERED","CHART_OPTIONS_DATACATEGORY","label","DATA_CATEGORY_NAMES","DataCategory","value","disabled","yAxisMinInterval","GIGABYTE","ChartDataTransform","CHART_OPTIONS_DATA_TRANSFORM","t","CUMULATIVE","PERIODIC","SeriesTypes","UsageChart","Component","xAxisDates","nextProps","prevState","usageDateStart","usageDateEnd","usageDateShowUtc","usageDateInterval","getXAxisDates","chartColors","dataCategory","theme","this","props","COLOR_PROJECTED","chartOther","chartMetadata","categoryOptions","usageStats","dataTransform","handleDataTransformation","state","selectDataCategory","find","o","Error","chartData","Object","keys","forEach","k","isProjected","PROJECTED","map","stat","tooltip","show","itemStyle","opacity","dataPeriod","statsPeriodToDays","undefined","barPeriod","parsePeriodToHours","xAxisTickInterval","xAxisLabelInterval","getXAxisLabelInterval","chartLabel","xAxisData","yAxisFormatter","val","formatUsageWithUnits","isAbbreviated","useUnitScaling","tooltipValueFormatter","getTooltipFormatter","chartSeries","series","barSeries","name","ACCEPTED","data","accepted","barMinHeight","stack","legendHoverLink","FILTERED","filtered","DROPPED","dropped","projected","concat","chartLegend","legend","length","push","chartTooltip","trigger","valueFormatter","renderChart","title","isLoading","isError","errors","height","mini","size","fontSizeExtraLarge","ErrorMessages","message","Fragment","getDynamicText","colors","grid","bottom","left","right","top","xAxis","type","axisTick","interval","alignWithLabel","axisLabel","formatter","slice","yAxis","min","minInterval","color","onLegendSelectChanged","Legend","fixed","render","footer","id","stats","transform","isCumulative","count","x","y","withTheme","space","p","fontSizeSmall","FORMAT_DATETIME_DAILY","FORMAT_DATETIME_HOURLY","getDateFromMoment","m","useUtc","days","moment","format","parsedInterval","parseStatsPeriod","datetime","utc","local","add","period","periodLength","dateStart","dateEnd","dateUtc","range","start","startOf","end","isValid","isAfter","numBars","numTicks","numLabels","daysBetweenLabels","daysBetweenTicks","i","getLabelIntervalLongPeriod","getLabelIntervalShortPeriod","MILLION","BILLION","usageQuantity","options","abbreviateUsageNumber","toLocaleString","formatBytesBase10","usageGb","maximumFractionDigits","getFormatUsageOptions","n","toFixed","isDisplayUtc","getSeriesApiInterval"],"sourceRoot":""}