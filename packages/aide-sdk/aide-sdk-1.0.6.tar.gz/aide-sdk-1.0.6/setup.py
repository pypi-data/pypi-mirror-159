# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['aide_sdk',
 'aide_sdk.inference',
 'aide_sdk.logger',
 'aide_sdk.manifests',
 'aide_sdk.messaging',
 'aide_sdk.messaging.schemas',
 'aide_sdk.model',
 'aide_sdk.utils']

package_data = \
{'': ['*']}

install_requires = \
['aide-infra==0.3.1.2',
 'dataclasses-json>=0.5.4,<0.6.0',
 'elasticsearch-dsl>=7.4.0,<8.0.0',
 'elasticsearch<=7.13.0',
 'json-logging>=1.3.0,<2.0.0',
 'jsonpickle>=2.0.0,<3.0.0',
 'marshmallow-polyfield>=5.10,<6.0',
 'marshmallow>=3.13.0,<4.0.0',
 'pika>=1.2.0,<2.0.0',
 'pydicom==2.1.2',
 'pynetdicom>=1.5.7,<2.0.0',
 'requests>=2.26.0,<3.0.0',
 'simplejson>=3.17.2,<4.0.0']

setup_kwargs = {
    'name': 'aide-sdk',
    'version': '1.0.6',
    'description': 'AI Deployment Engine SDK. This package allows you to build AI inference models to be run on the AIDE platform.',
    'long_description': '# AIDE SDK\n\n## Introduction\nThis library allows you to build AI inference models to be run on the AIDE platform.\n\n## Table of contents\n\n* [Quickstart](#quickstart)\n* [Packaging a model](#packaging--publishing)\n  * [The Manifest file](#manifest-file)  \n* [Accessing study data](#accessing-resources)\n* [Saving output](#saving-output-data)\n* [Logging & Model Failures](#logging)\n\n\n### Quickstart\nTo get started:\n\n```python3\nfrom aide_sdk.application import AideApplication\nfrom aide_sdk.inference.aideoperator import AideOperator\nfrom aide_sdk.model.operatorcontext import OperatorContext\nfrom aide_sdk.model.resource import Resource\nfrom aide_sdk.utils.file_storage import FileStorage\n\n\nclass MyModel(AideOperator):\n\n  def process(self, context: OperatorContext):\n    origin_dicom = context.origin\n    result = my_cool_stuff(origin_dicom)  # Your magic goes here\n    \n    file_manager = FileStorage(context)\n    path = file_manager.save_dicom("my_results", result)\n    \n    result_dicom = Resource(format="dicom", content_type="result", file_path=path)\n    context.add_resource(result_dicom)\n    return context\n\nAideApplication.start(operator=MyModel())\n```\n\n#### What we just did\nThe main application class is `AideApplication`. Once started, it will connect to the model\'s input queue and listen for new messages.\nThe single parameter required by Aide is the `operator` - this can be any object that implements the following method:\n\n1. `process(context: OperatorContext)` - This is the operation method, it receives an OperatorContext as input, and should return it as output. The context object is a special object which allows access to input resources.\n\n\n## Packaging & Publishing\nOnce your model is ready, it will need to be published onto the platform.\nIn order to do that, it\'ll need to be Dockerized.\n\n### Docker image requirements\n* The SDK needs to be installed on the image (using `pip install aide-sdk` or similar)\n* The entrypoint to the container needs to run `AideApplication.start`.\n* The following environment variables need to be set:\n    * MANIFEST_PATH - the path to a [manifest](#manifest-file) file. \n  \n\n### Manifest File\n\nThe manifest file provides the AIDE platform with the details it needs to use the model. It includes the following information:\n\n* `model_name` - string\n* `model_version` - string\n* `model_description` - string, The description of your model.\n* `predicate` - string, a valid [predicate string](#predicate-string).\n* `mode` - string, a valid [mode string](#model-modes).\n\n##### Model modes\nThe model mode determines how it\'ll be used by AIDE.\nThe mode string can have one of the following values:\n  * `QA` - QA mode, when the model is still being tested.\n  * `R` - Research mode.\n  * `CU` - Clinical use.\n\n##### Predicate String\nThe predicate string determines which inputs will be sent to the model.\nIt\'s a logical expression, evaluating to a boolean,\n\nIt\'s possible to use any comparison operator (`<`, `>`, `==`, `>=`, `<=`, `!=`) and combine using `AND` or `OR`.\n\n\nThe predicate supports evaluation against DICOM image metadata tags. Any DICOM tags that are wished to be evaluated against should be prefixed with the following: `DICOM_`. \n\nFor example:\n```json\nDICOM_Modality == "MR" AND DICOM_SliceThickness <= 10\n```\nThe above string will evaluate to true if the input DICOM "Modality" tag value is "MR" and the "SliceThickness" tag value is 10 or lower.\n\nIt is also possible to request specific resource types. For example:\n```json\nDICOM_Modality == "MR" AND DICOM_SliceThickness <= 10 AND resource.type == "nifty/origin"\n```\n\nResource types are defined as format/content-type.\n\n#### Manifest example\n```json\n{\n  "model_name": "test_model",\n  "model_version": "1.0.0",\n  "model_description": "This is a test model",\n  "mode": "QA",\n  "predicate": "tetststs"\n}\n```\n\n## Accessing Resources\n\nThe `process` method is called with an instance of `OperatorContext`, the reference for that object is shown below.\n\n### Object Reference\n\n#### OperatorContext\n\n###### Properties\nProperty | Type | Description\n--- | --- | ---\n`origin` | Origin | The origin object contains the initial input information to this pipeline. \n`resources` | List[Resource] | The resources added by previous operators in the pipeline. \n\n###### Methods\nMethod | Return type | Description\n--- | --- | ---\n`get_resources_by_type(format: str, content_type: str)` | List[[Resource](#resource)] | Returns the resources of a specific type. \n`add_resource(resource: Resource)` | None | Add a new [Resource](#resource) to the resources list. This resource will be available to the next operators.\n`set_error(error: str)` | None | Sets an error message in case the operator can\'t complete its operation. The execution will be marked as a failure.\n\n\n#### Resource\n\n###### Properties\nProperty | Type | Description\n--- | --- | ---\n`format` | str | The file format (e.g. nifti/dicom/etc) \n`content_type` | str | The content within this resource (eg "brain_scan", "white_matter")  \n`file_path` | str | The file path of this resource. Returned by the file manager when saving. \n`namespace` | str | The UID of the operator that created this resource. Added automatically when saving resources.  \n\n\n#### Origin(Resource)\nThe origin object is a special resource. It contains everything any resource contains, and additional information.\n\n###### Properties\nProperty | Type | Description\n--- | --- | ---\n`format` | str | The file format (e.g. "dicom") \n`content_type` | str | The content within this resource (eg "origin")  \n`file_path` | str | The path of this object. \n`namespace` | str | The UID of the operator that created this resource. Added automatically when saving resources.  \n`received_timestamp` | datetime | The time and date on which the origin object was first received by AIDE.  \n`patient_id` | str | The patient ID this data refers to.  \n\n\n#### DicomOrigin(Origin)\nThis origin object is used when the original input data is a DICOM study.\n\n###### Properties\nProperty | Type | Description\n--- | --- | ---\n`format` | str | The file format (e.g. "dicom") \n`content_type` | str | The content within this resource (eg "origin")  \n`file_path` | str | The path of this object. \n`namespace` | str | The UID of the operator that created this resource. Added automatically when saving resources.  \n`received_timestamp` | datetime | The time and date on which the origin object was first received by AIDE.  \n`patient_id` | str | The patient ID this data refers to.  \n`study_uid` | str | The DICOM Study ID.  \n`series` | List[[DicomSeries](#dicomseries)] | The DICOM series in this study.  \n\n###### Methods\nMethod | Return type | Description\n--- | --- | ---\n`get_series_by_id()` | [DicomSeries](#dicomseries) | Reads the dicom file and instantiates a pydicom `Dataset` from it.\n\n\n#### DicomSeries\nA DicomSeries object refers to a specific series of images.\n\n###### Properties\nProperty | Type | Description\n--- | --- | ---\n`series_id` | str | The UID of this series.\n`metadata` | dict | A dictionary containing series metadata.\n`images` | List[[DicomImage](#DicomImage)] | A list of dicom images included in this series. \n\n#### DicomImage\nThis is a wrapper object around a PyDicom `Dataset` object.\n\n###### Properties\nProperty | Type | Description\n--- | --- | ---\n`context_metadata` | dict | A dictionary containing the image metadata.\n`image_path` | str | The path to the .dcm file.\n\n###### Methods\nMethod | Return type | Description\n--- | --- | ---\n`load_dataset()` | pydicom.Dataset | Reads the dicom file and instantiates a pydicom `Dataset` from it.\n`get_filename()` | str | Returns the dicom filename (e.g. "filename.dcm")\n`get_context_metadata()` | str | Returns the image metadata, loading it if hasn\'t been loaded.\n`reload_context_metadata()` | str | Reloads the context metadata from the file.\n\n\n## Saving output Data\n\n#### FileStorage\n\nThis helper class allows you to save files, with convenience methods to help save DICOM images and PDF files. \nTo use it, instantiate it with an [OperatorContext](#operatorcontext) object.\n\n***It is recommended to include the source DICOM study/series id in the output/final report, this helps the end user to validate that the output was produced using the expected source data***\n\n###### Methods\nMethod | Return type | Description\n--- | --- | ---\n`save_file(file_bytes: bytes, file_name: str)` | str | Saves binary data to disk, and returns a path string with its location on disk. Requires binary data and a file name.\n`load_file(file_path: str)` | bytes | Loads a file from disk, using a path string.\n`save_dicom(folder_name: str, dataset: pydicom.Dataset)` | str | Saves a PyDicom `Dataset` to disk, and returns a path string with its location on disk. Requires a container folder name and the pydicom `Dataset`.\n`save_encapsulated_pdf(folder_name: str, dataset: Dataset, pdf_file_path: str)` | str | Save a PDF file, encapsulated within a DICOM file. This function require a folder name, the `Dataset` the PDF relates to, and the pdf file path. Returns the dicom path.\n\n\n## Logging\nLogging is possible using the `aide_sdk.logger.logger.LogManager` class:\n```python\nfrom aide_sdk.logger.logger import LogManager\n\nlogger = LogManager.get_logger()\nlogger.info("info message")\nlogger.warn("warn message")\nlogger.error("error message")\nlogger.exception("exception message")\n```\n\n### Failures vs Errors\nThere are two ways in which operators can fail - either a response can\'t be reached, for example because of a lack of statistical significance, or an error occurred while attempting to run the operator.\n\nFailures are still a valid result. To log an error response, use the [OperatorContext](#operatorcontext) `set_failure` method:\n```python\ncontext.set_failure("Couldn\'t reach conclusion")\nreturn context\n```\n\nHowever, unexpected errors should raise an exception. It is possible to use the `ModelError` exception for this:\n```python\nfrom aide_sdk.utils.exceptions import ModelError\n\ntry:\n  something()\nexcept Exception:\n  LogManager.get_logger().exception("Failed")\n  raise ModelError("Unknown error while running model")\n```',
    'author': 'Answer Digital',
    'author_email': 'aicentre@answerdigital.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://www.aicentre.co.uk/',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
