# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['pokerlib', 'pokerlib.statistics']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'pokerlib',
    'version': '0.9.0',
    'description': 'Python poker library',
    'long_description': "# pokerlib\n\n[![PyPI version](https://badge.fury.io/py/pokerlib.svg)](https://pypi.org/project/pokerlib)\n\n## General\n\nA Python poker library which focuses on simplifying a poker game implementation,\nwhen its io is supplied. It includes modules that help with hand parsing and poker game continuation.\n\nOne application of this library was made by the PokerMessenger app,\nwhich supplies library with io in the form of messenger group threads.\nThe app's repo is at https://github.com/kuco23/pokermessenger.\n\n## Usage\n\nLibrary consists of a module for parsing cards, which can be used seperately, and modules for running a poker game.\n\n### HandParser\n\nThis module allows for parsing of hands. A hand usually consists of 2 dealt cards plus 5 on the board, but you can use this\nfor any number of cards.\n\n```python\nfrom pokerlib import HandParser\nfrom pokerlib.enums import Rank, Suit, Hand\n\nhand = HandParser([\n    (Rank.SEVEN, Suit.HEART),\n    (Rank.EIGHT, Suit.SPADE),\n    (Rank.KING, Suit.DIAMOND),\n    (Rank.ACE, Suit.DIAMOND),\n    (Rank.QUEEN, Suit.DIAMOND),\n    (Rank.JACK, Suit.DIAMOND),\n    (Rank.TEN, Suit.DIAMOND)\n])\n\nhand.parse()\nprint(hand.handenum) # <Hand.STRAIGHTFLUSH: 8>\n```\n\nAll of the enums used are of type `IntEnum`, so you can also specify cards as integer pairs (look at `pokerlib.enums` file to see the exact enumeration of ranks and suits). You can also compare different hands as\n\n```python\nhand1 = HandParser([\n    (Rank.KING, Suit.SPADE),\n    (Rank.ACE, Suit.SPADE)\n])\n\nhand2 = HandParser([\n    (Rank.NINE, Suit.SPADE),\n    (Rank.TWO, Suit.CLUB)\n])\n\nboard = [\n    (Rank.EIGHT, Suit.SPADE),\n    (Rank.TEN, Suit.SPADE),\n    (Rank.JACK, Suit.SPADE),\n    (Rank.QUEEN, Suit.SPADE),\n    (Rank.TWO, Suit.HEART)\n]\n\nhand1 += board\nhand2 += board\n\nhand1.parse()\nhand2.parse()\n\nprint(hand1.handenum) # Hand.STRAIGHTFLUSH\nprint(hand2.handenum) # Hand.STRAIGHTFLUSH\nprint(hand1 > hand2) # True\n```\n\nyou can also get kickers for a hand,\n\n```python\nhand = HandParser([\n    (Rank.TWO, Suit.DIAMOND),\n    (Rank.ACE, Suit.CLUB),\n    (Rank.TWO, Suit.SPADE),\n    (Rank.THREE, Suit.DIAMOND),\n    (Rank.TEN, Suit.HEART),\n    (Rank.SIX, Suit.HEART),\n    (Rank.KING, Suit.CLUB)\n])\n\nhand.parse()\nprint(list(hand.kickercards))\n# [\n#   (<Rank.ACE: 12>, <Suit.CLUB: 1>),\n#   (<Rank.KING: 11>, <Suit.CLUB: 1>),\n#   (<Rank.TEN: 8>, <Suit.HEART: 3>)\n# ]\n```\n\nNote that `kickers` attribute saves the indices of `hand.cards` that form the `kickercards`.\n\n### Poker Game\n\nWe can establish a poker table by defining its configuration. Table also generates\noutput and we need to provide a function that handles it\n\n```python\nfrom pokerlib import Player, PlayerGroup, Table\n\n# just print output\nclass MyTable(Table):\n    def publicOut(self, action, **kwargs):\n        print(action, kwargs)\n\ntable = MyTable(\n    table_id = 0\n    seats = 2\n    players = PlayerGroup([])\n    buyin = 100\n    small_blind = 5\n    big_blind = 10\n)\n```\n\nTo add players, we can do\n\n```python\nplayer1 = Player(\n    table_id = table.id,\n    _id = 1,\n    name = 'alice',\n    money = table.buyin\n)\nplayer2 = Player(\n    table_id = table.id,\n    _id = 2,\n    name = 'bob',\n    money = table.buyin\n)\ntable += [player1, player2]\n```\n\nwhere 100 is the buyin amount. From here on, communication to the `table` object is established through enums:\n\n```python\nfrom pokerlib.enums import RoundPublicInId, TablePublicInId\n\ntable.publicIn(player1.id, TablePublicInId.STARTROUND)\ntable.publicIn(player1.id, RoundPublicInId.CALL)\ntable.publicIn(player2.id, RoundPublicInId.CHECK)\ntable.publicIn(player1.id, RoundPublicInId.CHECK)\ntable.publicIn(player2.id, RoundPublicInId.RAISE, raise_by=50)\ntable.publicIn(player1.id, RoundPublicInId.CALL)\ntable.publicIn(player1.id, RoundPublicInId.CHECK)\ntable.publicIn(player2.id, RoundPublicInId.CHECK)\ntable.publicIn(player1.id, RoundPublicInId.ALLIN)\ntable.publicIn(player2.id, RoundPublicInId.CALL)\n```\n\nWrong inputs are mostly ignored, and additional outputs are generated to\nkeep players informed of the game continuation (like e.g. `PLAYERACTIONREQUIRED`).\nFor all possible outputs check `RoundPublicInId` and `TablePublicInId` enums.\nA new round has to be initiated by one of the players every time it ends.\n\nA simple command line game, where you respond by enum names, can be started by\n\n```python\n# define a table with fixed players\ntable.publicIn(player1.id, TablePublicInId.STARTROUND)\nwhile True:\n    p = table.round.current_player\n    i = input(f'Player {p.name}: ')\n    cmd = RoundPublicInId.__members__[i]\n    table.publicIn(p.id, cmd)\n```\n\n## Tests\n\nBasic tests for this library are included.\nFor instance `round_test.py` can be started from os terminal, by typing `python round_test.py <player_num> <game_type>`, after which a simulation is run with not-that-informative data getting printed in stdout.\n\n## License\n\nGNU General Public License v3.0\n",
    'author': 'kuco23',
    'author_email': 'nseverkar@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/kuco23/pokerlib/',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)
