! This automatically generated Fortran wrapper file allows codes
! written in Fortran to be called directly from C and translates all
! C-style arguments into expected Fortran-style arguments (with
! assumed size, local type declarations, etc.).


MODULE C_BALL_TREE
USE ISO_FORTRAN_ENV , ONLY : REAL32 , INT64
USE PRUNE , ONLY : LEVEL
USE SWAP , ONLY : SWAP_I64
USE FAST_SELECT , ONLY : ARGSELECT
USE FAST_SORT , ONLY : ARGSORT
  IMPLICIT NONE


CONTAINS


  ! Getter and setter for MAX_COPY_BYTES.
  SUBROUTINE BALL_TREE_GET_MAX_COPY_BYTES(MAX_COPY_BYTES_LOCAL) BIND(C)
    USE BALL_TREE, ONLY: MAX_COPY_BYTES
    INTEGER(KIND=INT64) :: MAX_COPY_BYTES_LOCAL
    MAX_COPY_BYTES_LOCAL = MAX_COPY_BYTES
  END SUBROUTINE BALL_TREE_GET_MAX_COPY_BYTES
  SUBROUTINE BALL_TREE_SET_MAX_COPY_BYTES(MAX_COPY_BYTES_LOCAL) BIND(C)
    USE BALL_TREE, ONLY: MAX_COPY_BYTES
    INTEGER(KIND=INT64) :: MAX_COPY_BYTES_LOCAL
    MAX_COPY_BYTES = MAX_COPY_BYTES_LOCAL
  END SUBROUTINE BALL_TREE_SET_MAX_COPY_BYTES

  
  SUBROUTINE C_BUILD_TREE(POINTS_DIM_1, POINTS_DIM_2, POINTS, SQ_SUMS_DIM_1, SQ_SUMS, RADII_DIM_1, RADII, SPLITS_DIM_1, SPLITS, ORD&
&ER_DIM_1, ORDER, ROOT_PRESENT, ROOT, LEAF_SIZE_PRESENT, LEAF_SIZE, COMPUTED_SQ_SUMS_PRESENT, COMPUTED_SQ_SUMS) BIND(C)
    USE BALL_TREE, ONLY: BUILD_TREE
    IMPLICIT NONE
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: POINTS_DIM_1
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: POINTS_DIM_2
    REAL(KIND=REAL32), INTENT(INOUT), DIMENSION(POINTS_DIM_1,POINTS_DIM_2) :: POINTS
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: SQ_SUMS_DIM_1
    REAL(KIND=REAL32), INTENT(OUT), DIMENSION(SQ_SUMS_DIM_1) :: SQ_SUMS
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: RADII_DIM_1
    REAL(KIND=REAL32), INTENT(OUT), DIMENSION(RADII_DIM_1) :: RADII
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: SPLITS_DIM_1
    REAL(KIND=REAL32), INTENT(OUT), DIMENSION(SPLITS_DIM_1) :: SPLITS
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: ORDER_DIM_1
    INTEGER(KIND=INT64), INTENT(INOUT), DIMENSION(ORDER_DIM_1) :: ORDER
    LOGICAL, INTENT(IN) :: ROOT_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: ROOT
    LOGICAL, INTENT(IN) :: LEAF_SIZE_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: LEAF_SIZE
    LOGICAL, INTENT(IN) :: COMPUTED_SQ_SUMS_PRESENT
    LOGICAL, INTENT(IN) :: COMPUTED_SQ_SUMS
  
    IF (ROOT_PRESENT) THEN
      IF (LEAF_SIZE_PRESENT) THEN
        IF (COMPUTED_SQ_SUMS_PRESENT) THEN
          CALL BUILD_TREE(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, ROOT=ROOT, LEAF_SIZE=LEAF_SIZE, &
&COMPUTED_SQ_SUMS=COMPUTED_SQ_SUMS)
        ELSE
          CALL BUILD_TREE(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, ROOT=ROOT, LEAF_SIZE=LEAF_SIZE)
        END IF
      ELSE
        IF (COMPUTED_SQ_SUMS_PRESENT) THEN
          CALL BUILD_TREE(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, ROOT=ROOT, COMPUTED_SQ_SUMS=COMP&
&UTED_SQ_SUMS)
        ELSE
          CALL BUILD_TREE(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, ROOT=ROOT)
        END IF
      END IF
    ELSE
      IF (LEAF_SIZE_PRESENT) THEN
        IF (COMPUTED_SQ_SUMS_PRESENT) THEN
          CALL BUILD_TREE(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, COMPUTED_SQ&
&_SUMS=COMPUTED_SQ_SUMS)
        ELSE
          CALL BUILD_TREE(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE)
        END IF
      ELSE
        IF (COMPUTED_SQ_SUMS_PRESENT) THEN
          CALL BUILD_TREE(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, COMPUTED_SQ_SUMS=COMPUTED_SQ_SUM&
&S)
        ELSE
          CALL BUILD_TREE(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER)
        END IF
      END IF
    END IF
  END SUBROUTINE C_BUILD_TREE
  

  
  SUBROUTINE C_NEAREST(POINTS_DIM_1, POINTS_DIM_2, POINTS, K, TREE_DIM_1, TREE_DIM_2, TREE, SQ_SUMS_DIM_1, SQ_SUMS, RADII_DIM_1, RA&
&DII, SPLITS_DIM_1, SPLITS, ORDER_DIM_1, ORDER, LEAF_SIZE, INDICES_DIM_1, INDICES_DIM_2, INDICES, DISTS_DIM_1, DISTS_DIM_2, DISTS, &
&TO_SEARCH_PRESENT, TO_SEARCH, RANDOMNESS_PRESENT, RANDOMNESS) BIND(C)
    USE BALL_TREE, ONLY: NEAREST
    IMPLICIT NONE
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: POINTS_DIM_1
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: POINTS_DIM_2
    REAL(KIND=REAL32), INTENT(IN), DIMENSION(POINTS_DIM_1,POINTS_DIM_2) :: POINTS
    INTEGER(KIND=INT64), INTENT(IN) :: K
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: TREE_DIM_1
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: TREE_DIM_2
    REAL(KIND=REAL32), INTENT(IN), DIMENSION(TREE_DIM_1,TREE_DIM_2) :: TREE
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: SQ_SUMS_DIM_1
    REAL(KIND=REAL32), INTENT(IN), DIMENSION(SQ_SUMS_DIM_1) :: SQ_SUMS
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: RADII_DIM_1
    REAL(KIND=REAL32), INTENT(IN), DIMENSION(RADII_DIM_1) :: RADII
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: SPLITS_DIM_1
    REAL(KIND=REAL32), INTENT(IN), DIMENSION(SPLITS_DIM_1) :: SPLITS
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: ORDER_DIM_1
    INTEGER(KIND=INT64), INTENT(IN), DIMENSION(ORDER_DIM_1) :: ORDER
    INTEGER(KIND=INT64), INTENT(IN) :: LEAF_SIZE
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: INDICES_DIM_1
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: INDICES_DIM_2
    INTEGER(KIND=INT64), INTENT(OUT), DIMENSION(INDICES_DIM_1,INDICES_DIM_2) :: INDICES
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: DISTS_DIM_1
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: DISTS_DIM_2
    REAL(KIND=REAL32), INTENT(OUT), DIMENSION(DISTS_DIM_1,DISTS_DIM_2) :: DISTS
    LOGICAL, INTENT(IN) :: TO_SEARCH_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: TO_SEARCH
    LOGICAL, INTENT(IN) :: RANDOMNESS_PRESENT
    REAL(KIND=REAL32), INTENT(IN) :: RANDOMNESS
  
    IF (TO_SEARCH_PRESENT) THEN
      IF (RANDOMNESS_PRESENT) THEN
        CALL NEAREST(POINTS=POINTS, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, &
&INDICES=INDICES, DISTS=DISTS, TO_SEARCH=TO_SEARCH, RANDOMNESS=RANDOMNESS)
      ELSE
        CALL NEAREST(POINTS=POINTS, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, &
&INDICES=INDICES, DISTS=DISTS, TO_SEARCH=TO_SEARCH)
      END IF
    ELSE
      IF (RANDOMNESS_PRESENT) THEN
        CALL NEAREST(POINTS=POINTS, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, &
&INDICES=INDICES, DISTS=DISTS, RANDOMNESS=RANDOMNESS)
      ELSE
        CALL NEAREST(POINTS=POINTS, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, &
&INDICES=INDICES, DISTS=DISTS)
      END IF
    END IF
  END SUBROUTINE C_NEAREST
  

  
  SUBROUTINE C_PT_NEAREST(POINT_DIM_1, POINT, K, TREE_DIM_1, TREE_DIM_2, TREE, SQ_SUMS_DIM_1, SQ_SUMS, RADII_DIM_1, RADII, SPLITS_D&
&IM_1, SPLITS, ORDER_DIM_1, ORDER, LEAF_SIZE, INDICES_DIM_1, INDICES, DISTS_DIM_1, DISTS, RANDOMNESS, CHECKS_PRESENT, CHECKS, FOUND&
&_PRESENT, FOUND, PT_SS_PRESENT, PT_SS, D_ROOT_PRESENT, D_ROOT) BIND(C)
    USE BALL_TREE, ONLY: PT_NEAREST
    IMPLICIT NONE
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: POINT_DIM_1
    REAL(KIND=REAL32), INTENT(IN), DIMENSION(POINT_DIM_1) :: POINT
    INTEGER(KIND=INT64), INTENT(IN) :: K
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: TREE_DIM_1
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: TREE_DIM_2
    REAL(KIND=REAL32), INTENT(IN), DIMENSION(TREE_DIM_1,TREE_DIM_2) :: TREE
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: SQ_SUMS_DIM_1
    REAL(KIND=REAL32), INTENT(IN), DIMENSION(SQ_SUMS_DIM_1) :: SQ_SUMS
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: RADII_DIM_1
    REAL(KIND=REAL32), INTENT(IN), DIMENSION(RADII_DIM_1) :: RADII
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: SPLITS_DIM_1
    REAL(KIND=REAL32), INTENT(IN), DIMENSION(SPLITS_DIM_1) :: SPLITS
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: ORDER_DIM_1
    INTEGER(KIND=INT64), INTENT(IN), DIMENSION(ORDER_DIM_1) :: ORDER
    INTEGER(KIND=INT64), INTENT(IN) :: LEAF_SIZE
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: INDICES_DIM_1
    INTEGER(KIND=INT64), INTENT(OUT), DIMENSION(INDICES_DIM_1) :: INDICES
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: DISTS_DIM_1
    REAL(KIND=REAL32), INTENT(OUT), DIMENSION(DISTS_DIM_1) :: DISTS
    REAL(KIND=REAL32), INTENT(IN) :: RANDOMNESS
    LOGICAL, INTENT(IN) :: CHECKS_PRESENT
    INTEGER(KIND=INT64), INTENT(INOUT) :: CHECKS
    LOGICAL, INTENT(IN) :: FOUND_PRESENT
    INTEGER(KIND=INT64), INTENT(INOUT) :: FOUND
    LOGICAL, INTENT(IN) :: PT_SS_PRESENT
    REAL(KIND=REAL32), INTENT(IN) :: PT_SS
    LOGICAL, INTENT(IN) :: D_ROOT_PRESENT
    REAL(KIND=REAL32), INTENT(IN) :: D_ROOT
  
    IF (CHECKS_PRESENT) THEN
      IF (FOUND_PRESENT) THEN
        IF (PT_SS_PRESENT) THEN
          IF (D_ROOT_PRESENT) THEN
            CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_S&
&IZE, INDICES=INDICES, DISTS=DISTS, RANDOMNESS=RANDOMNESS, CHECKS=CHECKS, FOUND=FOUND, PT_SS=PT_SS, D_ROOT=D_ROOT)
          ELSE
            CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_S&
&IZE, INDICES=INDICES, DISTS=DISTS, RANDOMNESS=RANDOMNESS, CHECKS=CHECKS, FOUND=FOUND, PT_SS=PT_SS)
          END IF
        ELSE
          IF (D_ROOT_PRESENT) THEN
            CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_S&
&IZE, INDICES=INDICES, DISTS=DISTS, RANDOMNESS=RANDOMNESS, CHECKS=CHECKS, FOUND=FOUND, D_ROOT=D_ROOT)
          ELSE
            CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_S&
&IZE, INDICES=INDICES, DISTS=DISTS, RANDOMNESS=RANDOMNESS, CHECKS=CHECKS, FOUND=FOUND)
          END IF
        END IF
      ELSE
        IF (PT_SS_PRESENT) THEN
          IF (D_ROOT_PRESENT) THEN
            CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_S&
&IZE, INDICES=INDICES, DISTS=DISTS, RANDOMNESS=RANDOMNESS, CHECKS=CHECKS, PT_SS=PT_SS, D_ROOT=D_ROOT)
          ELSE
            CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_S&
&IZE, INDICES=INDICES, DISTS=DISTS, RANDOMNESS=RANDOMNESS, CHECKS=CHECKS, PT_SS=PT_SS)
          END IF
        ELSE
          IF (D_ROOT_PRESENT) THEN
            CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_S&
&IZE, INDICES=INDICES, DISTS=DISTS, RANDOMNESS=RANDOMNESS, CHECKS=CHECKS, D_ROOT=D_ROOT)
          ELSE
            CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_S&
&IZE, INDICES=INDICES, DISTS=DISTS, RANDOMNESS=RANDOMNESS, CHECKS=CHECKS)
          END IF
        END IF
      END IF
    ELSE
      IF (FOUND_PRESENT) THEN
        IF (PT_SS_PRESENT) THEN
          IF (D_ROOT_PRESENT) THEN
            CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_S&
&IZE, INDICES=INDICES, DISTS=DISTS, RANDOMNESS=RANDOMNESS, FOUND=FOUND, PT_SS=PT_SS, D_ROOT=D_ROOT)
          ELSE
            CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_S&
&IZE, INDICES=INDICES, DISTS=DISTS, RANDOMNESS=RANDOMNESS, FOUND=FOUND, PT_SS=PT_SS)
          END IF
        ELSE
          IF (D_ROOT_PRESENT) THEN
            CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_S&
&IZE, INDICES=INDICES, DISTS=DISTS, RANDOMNESS=RANDOMNESS, FOUND=FOUND, D_ROOT=D_ROOT)
          ELSE
            CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_S&
&IZE, INDICES=INDICES, DISTS=DISTS, RANDOMNESS=RANDOMNESS, FOUND=FOUND)
          END IF
        END IF
      ELSE
        IF (PT_SS_PRESENT) THEN
          IF (D_ROOT_PRESENT) THEN
            CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_S&
&IZE, INDICES=INDICES, DISTS=DISTS, RANDOMNESS=RANDOMNESS, PT_SS=PT_SS, D_ROOT=D_ROOT)
          ELSE
            CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_S&
&IZE, INDICES=INDICES, DISTS=DISTS, RANDOMNESS=RANDOMNESS, PT_SS=PT_SS)
          END IF
        ELSE
          IF (D_ROOT_PRESENT) THEN
            CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_S&
&IZE, INDICES=INDICES, DISTS=DISTS, RANDOMNESS=RANDOMNESS, D_ROOT=D_ROOT)
          ELSE
            CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, LEAF_SIZE=LEAF_S&
&IZE, INDICES=INDICES, DISTS=DISTS, RANDOMNESS=RANDOMNESS)
          END IF
        END IF
      END IF
    END IF
  END SUBROUTINE C_PT_NEAREST
  

  
  SUBROUTINE C_FIX_ORDER(POINTS_DIM_1, POINTS_DIM_2, POINTS, SQ_SUMS_DIM_1, SQ_SUMS, RADII_DIM_1, RADII, SPLITS_DIM_1, SPLITS, ORDE&
&R_DIM_1, ORDER, COPY_PRESENT, COPY) BIND(C)
    USE BALL_TREE, ONLY: FIX_ORDER
    IMPLICIT NONE
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: POINTS_DIM_1
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: POINTS_DIM_2
    REAL(KIND=REAL32), INTENT(INOUT), DIMENSION(POINTS_DIM_1,POINTS_DIM_2) :: POINTS
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: SQ_SUMS_DIM_1
    REAL(KIND=REAL32), INTENT(INOUT), DIMENSION(SQ_SUMS_DIM_1) :: SQ_SUMS
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: RADII_DIM_1
    REAL(KIND=REAL32), INTENT(INOUT), DIMENSION(RADII_DIM_1) :: RADII
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: SPLITS_DIM_1
    REAL(KIND=REAL32), INTENT(INOUT), DIMENSION(SPLITS_DIM_1) :: SPLITS
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: ORDER_DIM_1
    INTEGER(KIND=INT64), INTENT(INOUT), DIMENSION(ORDER_DIM_1) :: ORDER
    LOGICAL, INTENT(IN) :: COPY_PRESENT
    LOGICAL, INTENT(IN) :: COPY
  
    IF (COPY_PRESENT) THEN
      CALL FIX_ORDER(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER, COPY=COPY)
    ELSE
      CALL FIX_ORDER(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, SPLITS=SPLITS, ORDER=ORDER)
    END IF
  END SUBROUTINE C_FIX_ORDER
  
END MODULE C_BALL_TREE

