{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Alpha environment documention Alpha is an ecosystem based on multiple frameworks and libraries for both frontend and backend . Backend: Alphaz Alphaz is a backend toolbox/framework based on a combination between Flask, SqlAlchemy and a multitude of other libraries. Note The overriding goal for Alphaz is to ease the backend development and easely link python backend to Angular frontend [Alphaa]. Features API Routing parameters management upgrade Enhanced json files configuration Tech Alphaz uses a number of open source projects to work properly: Flask - a micro web framework SqlAlchemy - a database toolkit Flask-SqlAlchemy - an extension for Flask that adds support for SQLAlchemy Project layout How to setup Alpha : Alpha Frontend: Alphaa Alphaa is a frontend toolbox/framework Note The overriding goal for Alphaa is to ease the frontend development and easely link Angular frontend to python backend [Alphaz]. Features Enhanced services Master class Project layout How to setup Alpha : Alpha","title":"Home"},{"location":"#welcome-to-alpha-environment-documention","text":"Alpha is an ecosystem based on multiple frameworks and libraries for both frontend and backend .","title":"Welcome to Alpha environment documention"},{"location":"#backend-alphaz","text":"Alphaz is a backend toolbox/framework based on a combination between Flask, SqlAlchemy and a multitude of other libraries. Note The overriding goal for Alphaz is to ease the backend development and easely link python backend to Angular frontend [Alphaa].","title":"Backend: Alphaz"},{"location":"#features","text":"API Routing parameters management upgrade Enhanced json files configuration","title":"Features"},{"location":"#tech","text":"Alphaz uses a number of open source projects to work properly: Flask - a micro web framework SqlAlchemy - a database toolkit Flask-SqlAlchemy - an extension for Flask that adds support for SQLAlchemy","title":"Tech"},{"location":"#project-layout","text":"How to setup Alpha : Alpha","title":"Project layout"},{"location":"#frontend-alphaa","text":"Alphaa is a frontend toolbox/framework Note The overriding goal for Alphaa is to ease the frontend development and easely link Angular frontend to python backend [Alphaz].","title":"Frontend: Alphaa"},{"location":"#features_1","text":"Enhanced services Master class","title":"Features"},{"location":"#project-layout_1","text":"How to setup Alpha : Alpha","title":"Project layout"},{"location":"alpha_api/","text":"Alpha API system Introduction The api system is completely based on Flask and compatible. You could use Flask inside Alpha system without any issue. Launch To start the api execute the api.py file python api.py Note set ALPHA_CONF environment parameter is you want to set the environment. Verify the deployment by navigating to your server address in your preferred browser: 127 .0.0.1:<port> How to use Your could import it using simply from the utils : from alphaz.utils.api import api or from the core if you are using it from core import core api = core . api api is the equivalent for app in Flask framework. Configuration The api is automatically configured from the api.jon file. Admin You could specify ip in the admins parameter. Routes Basic To specify an api route, juste use the route flag: from alphaz.utils.api import route , api , Parameter @route ( \"route_name\" ) def method_name (): return \"hello\" Method automatically convert the output to the right format. Default format is json Description A description could be specified: @route ( \"route_name\" , description = \"This route say hello\" ) def method_name (): return \"hello\" Category The routes are organized by category , by default the route category is defined by it file name , but it could be specified using the cat parameter: @route ( \"route_name\" , category = \"politeness\" ) def method_name (): return \"hello\" Parameters Simple You could simply define parameters by listing all parameters in parameters list: from alphaz.utils.api import route , api , Parameter @route ( \"books\" , parameters = [ \"name\" ]) def method_name (): return \"Book name is %s or %s \" % ( api [ \"name\" ], api . get ( \"name\" , default = \"\" )) Parameter value is accessed by api instance, using get method, they could also be accessed using get_parameters method from api instance. Object Or you could use the Parameter class to specify properties such as: ptype : value type int, str, bool, SqlAlchemy model parameter is automatically converted to the specified type if conversion failed an exception is raised required : the parameter is required or not default : default parameter value options : authorized values mode : input mode cacheable : parameter is taken into acount in the caching system or not private : parameter is hiden from documentation or not @route ( \"/logs\" , parameters = [ Parameter ( 'page' , required = True , ptype = int ), Parameter ( 'startDate' , required = True ), Parameter ( 'endDate' , default = None ), Parameter ( 'error' , options = [ \"Y\" , \"N\" ]) ]) def admin_logs (): return get_logs ( ** api . get_parameters ()) Promote this method as it allows a better control on parameters SqlAlchemy model If you specify a SqlAlchemy model as a type it will be automatically converted to the specified model. from core import core db = core . db class Logs ( db . Model , AlphaTable ): __tablename__ = 'LOGS' id = AlphaColumn ( Integer , nullable = False , primary_key = True ) name = AlphaColumn ( String , nullable = False ) @route ( \"logs\" , parameters = [ Parameter ( 'log' , ptype = Logs ) ]) def admin_logs (): db . add ( api [ 'log' ]) Methods Methods are specified the same way as in Flask , using methods parameter: @route ( 'logs' , methods = [ \"GET\" ]) def get_logs (): return db . select ( Logs ) @route ( 'logs' , methods = [ \"POST\" ]) def set_logs (): return db . add ( Logs ) Methods can be managed using different routes or within a single route : @route ( 'logs' , methods = [ \"GET\" , \"POST\" , \"DELETE\" ]) def get_logs (): if api . is_get (): return db . select ( Logs ) elif api . is_post (): return db . add ( Logs ) elif api . is_delete (): return db . delete ( Logs ) Authorizations Route can be protected using the login system or admin rights. Login system To protect a route using the login system you must specify: logged=True @route ( 'protected' , logged = True ) def protected_route (): user = api . get_logged_user () return user User information can be accessed using get_logged_user method. Cache A cache system is implemented, in order to use it you must specify the Admin In progress Issues In progress Database alias In progress label_length","title":"Api"},{"location":"alpha_api/#alpha-api-system","text":"","title":"Alpha API system"},{"location":"alpha_api/#introduction","text":"The api system is completely based on Flask and compatible. You could use Flask inside Alpha system without any issue.","title":"Introduction"},{"location":"alpha_api/#launch","text":"To start the api execute the api.py file python api.py Note set ALPHA_CONF environment parameter is you want to set the environment. Verify the deployment by navigating to your server address in your preferred browser: 127 .0.0.1:<port>","title":"Launch"},{"location":"alpha_api/#how-to-use","text":"Your could import it using simply from the utils : from alphaz.utils.api import api or from the core if you are using it from core import core api = core . api api is the equivalent for app in Flask framework.","title":"How to use"},{"location":"alpha_api/#configuration","text":"The api is automatically configured from the api.jon file.","title":"Configuration"},{"location":"alpha_api/#admin","text":"You could specify ip in the admins parameter.","title":"Admin"},{"location":"alpha_api/#routes","text":"","title":"Routes"},{"location":"alpha_api/#basic","text":"To specify an api route, juste use the route flag: from alphaz.utils.api import route , api , Parameter @route ( \"route_name\" ) def method_name (): return \"hello\" Method automatically convert the output to the right format. Default format is json","title":"Basic"},{"location":"alpha_api/#description","text":"A description could be specified: @route ( \"route_name\" , description = \"This route say hello\" ) def method_name (): return \"hello\"","title":"Description"},{"location":"alpha_api/#category","text":"The routes are organized by category , by default the route category is defined by it file name , but it could be specified using the cat parameter: @route ( \"route_name\" , category = \"politeness\" ) def method_name (): return \"hello\"","title":"Category"},{"location":"alpha_api/#parameters","text":"","title":"Parameters"},{"location":"alpha_api/#simple","text":"You could simply define parameters by listing all parameters in parameters list: from alphaz.utils.api import route , api , Parameter @route ( \"books\" , parameters = [ \"name\" ]) def method_name (): return \"Book name is %s or %s \" % ( api [ \"name\" ], api . get ( \"name\" , default = \"\" )) Parameter value is accessed by api instance, using get method, they could also be accessed using get_parameters method from api instance.","title":"Simple"},{"location":"alpha_api/#object","text":"Or you could use the Parameter class to specify properties such as: ptype : value type int, str, bool, SqlAlchemy model parameter is automatically converted to the specified type if conversion failed an exception is raised required : the parameter is required or not default : default parameter value options : authorized values mode : input mode cacheable : parameter is taken into acount in the caching system or not private : parameter is hiden from documentation or not @route ( \"/logs\" , parameters = [ Parameter ( 'page' , required = True , ptype = int ), Parameter ( 'startDate' , required = True ), Parameter ( 'endDate' , default = None ), Parameter ( 'error' , options = [ \"Y\" , \"N\" ]) ]) def admin_logs (): return get_logs ( ** api . get_parameters ()) Promote this method as it allows a better control on parameters","title":"Object"},{"location":"alpha_api/#sqlalchemy-model","text":"If you specify a SqlAlchemy model as a type it will be automatically converted to the specified model. from core import core db = core . db class Logs ( db . Model , AlphaTable ): __tablename__ = 'LOGS' id = AlphaColumn ( Integer , nullable = False , primary_key = True ) name = AlphaColumn ( String , nullable = False ) @route ( \"logs\" , parameters = [ Parameter ( 'log' , ptype = Logs ) ]) def admin_logs (): db . add ( api [ 'log' ])","title":"SqlAlchemy model"},{"location":"alpha_api/#methods","text":"Methods are specified the same way as in Flask , using methods parameter: @route ( 'logs' , methods = [ \"GET\" ]) def get_logs (): return db . select ( Logs ) @route ( 'logs' , methods = [ \"POST\" ]) def set_logs (): return db . add ( Logs ) Methods can be managed using different routes or within a single route : @route ( 'logs' , methods = [ \"GET\" , \"POST\" , \"DELETE\" ]) def get_logs (): if api . is_get (): return db . select ( Logs ) elif api . is_post (): return db . add ( Logs ) elif api . is_delete (): return db . delete ( Logs )","title":"Methods"},{"location":"alpha_api/#authorizations","text":"Route can be protected using the login system or admin rights.","title":"Authorizations"},{"location":"alpha_api/#login-system","text":"To protect a route using the login system you must specify: logged=True @route ( 'protected' , logged = True ) def protected_route (): user = api . get_logged_user () return user User information can be accessed using get_logged_user method.","title":"Login system"},{"location":"alpha_api/#cache","text":"A cache system is implemented, in order to use it you must specify the","title":"Cache"},{"location":"alpha_api/#admin_1","text":"In progress","title":"Admin"},{"location":"alpha_api/#issues","text":"In progress","title":"Issues"},{"location":"alpha_api/#database-alias","text":"In progress label_length","title":"Database alias"},{"location":"alpha_configuration/","text":"Dynamic json alpha configuration syntax","title":"Configuration"},{"location":"alpha_configuration/#dynamic-json-alpha-configuration-syntax","text":"","title":"Dynamic json alpha configuration syntax"},{"location":"alpha_core/","text":"Alpha core system Purpose The core is used as a central point to manage various system: - logging system - database access - api system - dynamic configuration How to use You could: Use the alphaz core and initiate it at the start of you project: from alphaz.models.main import AlphaCore core = AlphaCore ( __file__ ) Or create a core.py file at the root of your project containing at least: from alphaz.models.main import AlphaCore , singleton @singleton class Core ( AlphaCore ): def __init__ ( self , file : str ): super () . __init__ ( file ) core = Core ( __file__ ) Note This is the recommended way, so that you could custom the Core class Logging from core import core LOG = core . get_logger ( 'name' ) LOG . info ( 'message' ) Database from core import core DB = core . db API from core import core API = core . api Configuration from core import core CONFIG = core . config tmp_directory_path = CONFIG . get ( 'directories/tmp' )","title":"Core"},{"location":"alpha_core/#alpha-core-system","text":"","title":"Alpha core system"},{"location":"alpha_core/#purpose","text":"The core is used as a central point to manage various system: - logging system - database access - api system - dynamic configuration","title":"Purpose"},{"location":"alpha_core/#how-to-use","text":"You could: Use the alphaz core and initiate it at the start of you project: from alphaz.models.main import AlphaCore core = AlphaCore ( __file__ ) Or create a core.py file at the root of your project containing at least: from alphaz.models.main import AlphaCore , singleton @singleton class Core ( AlphaCore ): def __init__ ( self , file : str ): super () . __init__ ( file ) core = Core ( __file__ ) Note This is the recommended way, so that you could custom the Core class","title":"How to use"},{"location":"alpha_core/#logging","text":"from core import core LOG = core . get_logger ( 'name' ) LOG . info ( 'message' )","title":"Logging"},{"location":"alpha_core/#database","text":"from core import core DB = core . db","title":"Database"},{"location":"alpha_core/#api","text":"from core import core API = core . api","title":"API"},{"location":"alpha_core/#configuration","text":"from core import core CONFIG = core . config tmp_directory_path = CONFIG . get ( 'directories/tmp' )","title":"Configuration"},{"location":"alpha_database/","text":"Alpha database system Automatic structure Compared to native SqlAlchemy in alpha you only need to instantiate the table model: from alphaz.models.database.models import AlphaTable , AlphaColumn DB = core . db class DuckType ( DB . Model , AlphaTable ): __bind_key__ = DB __tablename__ = \"duck_type\" type_id = AlphaColumn ( INTEGER , primary_key = True , autoincrement = True ) name = AlphaColumn ( TEXT , nullable = False , default = \"SuperDuck\" ) class DuckMedal ( DB . Model , AlphaTable ): __bind_key__ = DB __tablename__ = \"duck_medal\" name = AlphaColumn ( TEXT , nullable = False , default = \"Lucky\" ) duck_id = AlphaColumn ( INTEGER , ForeignKey ( 'duck.duck_id' ), nullable = False , default = - 1 ) class Duck ( DB . Model , AlphaTable ): __bind_key__ = DB __tablename__ = \"duck\" duck_id = AlphaColumn ( INTEGER , primary_key = True , autoincrement = True , visible = False ) name = AlphaColumn ( TEXT , nullable = False , default = \"\" ) # Many to one duck_type_id = AlphaColumn ( INTEGER , ForeignKey ( 'duck_type.type_id' ), nullable = False , default = - 1 , visible = False ) duck_type = relationship ( \"DuckType\" ) # One to many medals = relationship ( \"DuckMedals\" ) By default a select query on Duck class defined like this: master_duck = DuckType ( ame = \"Master Duck\" ) DB . add ( master_duck ) ducky = Duck ( name = \"Ducky\" , duck_type = master_duck ) DB . add ( ducky ) honnor_medal = DuckMedal ( name = \"Honnor\" , duck_id = ducky . duck_id ) lucky_medal = DuckMedal ( name = \"Lucky\" , duck_id = ducky . duck_id ) DB . add ( ducky ) ducks = DB . select ( Duck , filters = [ Duck . name == \"Ducky\" ], first = True ) Will result in this: { \"duck_id\" : 1 , \"name\" : \"Ducky\" , \"duck_type\" : { \"type_id\" : 1 , \"duck_type\" : \"Master Duck\" }, \"medals\" : [{ \"name\" : \"Honnor\" }, { \"name\" : \"Lucky\" }] } Schema Note The associated Schema is created automatically, with classic and nested fields. However Marshmallow schema could be defined using the classic way Marshmallow : Set visible to False if you dont want the column to appears in the Schema. Important Schema must be defined after the Model DB = core . db class DuckTypeSchema ( Schema ): type_id = fields . Integer () name = fields . String () class DuckMedalSchema ( Schema ): name = fields . String () class DuckSchema ( Schema ): name = fields . String () # Many to One duck_type = fields . Nested ( DuckTypeSchema ) # One to many medals = fields . List ( fields . Nested ( DuckMedalSchema )) Important Alpha will automatically detect the schema if the name is defined as \"{ModelName}Schema\" and is located in the same file. Note In this mode, Schema could be defined automatically, excepted for nested fields. Specific Schema Schema could be specified for every request: DB . select ( model = Duck , schema = DuckSchema ) Alpha notation init This enable the use of model columns which is not possible using SqlAlchemy: attr = { Duck . name : name , Duck . duck_type_id : duck_type_id , } duck = Duck () duck . init ( attr ) or duck = Duck () duck . init ({ Duck . name : name , Duck . duck_type_id : duck_type_id , }) Instead of: attr = { Duck . name : name , Duck . duck_type_id : duck_type_id , } duck = Duck () duck . init ( ** { x . key : y for x , y in attr . items ()}) Update Classic SQLAlchemy Select query duck = Duck . query . filter_by ( name = name ) . first () duck . duck_type_id = duck_type_id db . session . commit () Init new_duck = Duck ( \"name\" : name , \"duck_type_id\" : duck_type_id ) db . session . merge ( new_duck ) db . session . commit () or attr = { \"name\" : name , \"duck_type_id\" : duck_type_id , } duck = Duck ( ** attr ) db . session . merge ( new_duck ) db . session . commit () Init and update new_duck = Duck () new_duck . name = name new_duck . duck_type_id = duck_type_id db . session . merge ( new_duck ) db . session . commit () Update Alphaz include a special update method that simplifies updates via api routes Model as a parameter Warning This is not recommanded because you could not specified if a field of Duck is required or not @route ( path = 'duck' , methods = [ \"PUT\" ], parameters = [ Parameter ( \"duck\" , ptype = Duck , required = True ) ], ) def update_duck (): return DB . update ( api [ \"duck\" ]) Route parameters to model @route ( path = 'duck' , methods = [ \"PUT\" ], parameters = [ Parameter ( \"name\" , ptype = str , required = True ), Parameter ( \"duck_type_id\" , ptype = int ) ], ) def update_duck (): return DB . update ( Duck ( ** api . get_parameters ()), not_none = True ) # not_none is to set if you dont want None values to update fields or using a function: def update_duck ( name : str , duck_type_id : str ): return DB . update ( Duck ( ** locals ())) @route ( path = 'duck' , methods = [ \"PUT\" ], parameters = [ Parameter ( \"name\" , ptype = str , required = True ), Parameter ( \"duck_type_id\" , ptype = int ) ], ) def update_duck (): return update_duck ( ** api . get_parameters ()) Relations Relation filter return DB . select ( Duck , filters = [ Duck . duck_type . has ( DuckType . name . like ( name ))] ) Will produce a query like: SELECT * FROM DUCK WHERE EXISTS ( SELECT 1 FROM DUCKTYPE where DUCKTYPE . id == DUCK . ducktype_id and DUCKTYPE . name = name ) Doc","title":"Database"},{"location":"alpha_database/#alpha-database-system","text":"","title":"Alpha database system"},{"location":"alpha_database/#automatic-structure","text":"Compared to native SqlAlchemy in alpha you only need to instantiate the table model: from alphaz.models.database.models import AlphaTable , AlphaColumn DB = core . db class DuckType ( DB . Model , AlphaTable ): __bind_key__ = DB __tablename__ = \"duck_type\" type_id = AlphaColumn ( INTEGER , primary_key = True , autoincrement = True ) name = AlphaColumn ( TEXT , nullable = False , default = \"SuperDuck\" ) class DuckMedal ( DB . Model , AlphaTable ): __bind_key__ = DB __tablename__ = \"duck_medal\" name = AlphaColumn ( TEXT , nullable = False , default = \"Lucky\" ) duck_id = AlphaColumn ( INTEGER , ForeignKey ( 'duck.duck_id' ), nullable = False , default = - 1 ) class Duck ( DB . Model , AlphaTable ): __bind_key__ = DB __tablename__ = \"duck\" duck_id = AlphaColumn ( INTEGER , primary_key = True , autoincrement = True , visible = False ) name = AlphaColumn ( TEXT , nullable = False , default = \"\" ) # Many to one duck_type_id = AlphaColumn ( INTEGER , ForeignKey ( 'duck_type.type_id' ), nullable = False , default = - 1 , visible = False ) duck_type = relationship ( \"DuckType\" ) # One to many medals = relationship ( \"DuckMedals\" ) By default a select query on Duck class defined like this: master_duck = DuckType ( ame = \"Master Duck\" ) DB . add ( master_duck ) ducky = Duck ( name = \"Ducky\" , duck_type = master_duck ) DB . add ( ducky ) honnor_medal = DuckMedal ( name = \"Honnor\" , duck_id = ducky . duck_id ) lucky_medal = DuckMedal ( name = \"Lucky\" , duck_id = ducky . duck_id ) DB . add ( ducky ) ducks = DB . select ( Duck , filters = [ Duck . name == \"Ducky\" ], first = True ) Will result in this: { \"duck_id\" : 1 , \"name\" : \"Ducky\" , \"duck_type\" : { \"type_id\" : 1 , \"duck_type\" : \"Master Duck\" }, \"medals\" : [{ \"name\" : \"Honnor\" }, { \"name\" : \"Lucky\" }] }","title":"Automatic structure"},{"location":"alpha_database/#schema","text":"Note The associated Schema is created automatically, with classic and nested fields. However Marshmallow schema could be defined using the classic way Marshmallow : Set visible to False if you dont want the column to appears in the Schema. Important Schema must be defined after the Model DB = core . db class DuckTypeSchema ( Schema ): type_id = fields . Integer () name = fields . String () class DuckMedalSchema ( Schema ): name = fields . String () class DuckSchema ( Schema ): name = fields . String () # Many to One duck_type = fields . Nested ( DuckTypeSchema ) # One to many medals = fields . List ( fields . Nested ( DuckMedalSchema )) Important Alpha will automatically detect the schema if the name is defined as \"{ModelName}Schema\" and is located in the same file. Note In this mode, Schema could be defined automatically, excepted for nested fields.","title":"Schema"},{"location":"alpha_database/#specific-schema","text":"Schema could be specified for every request: DB . select ( model = Duck , schema = DuckSchema )","title":"Specific Schema"},{"location":"alpha_database/#alpha-notation","text":"","title":"Alpha notation"},{"location":"alpha_database/#init","text":"This enable the use of model columns which is not possible using SqlAlchemy: attr = { Duck . name : name , Duck . duck_type_id : duck_type_id , } duck = Duck () duck . init ( attr ) or duck = Duck () duck . init ({ Duck . name : name , Duck . duck_type_id : duck_type_id , }) Instead of: attr = { Duck . name : name , Duck . duck_type_id : duck_type_id , } duck = Duck () duck . init ( ** { x . key : y for x , y in attr . items ()})","title":"init"},{"location":"alpha_database/#update","text":"","title":"Update"},{"location":"alpha_database/#classic-sqlalchemy","text":"","title":"Classic SQLAlchemy"},{"location":"alpha_database/#select-query","text":"duck = Duck . query . filter_by ( name = name ) . first () duck . duck_type_id = duck_type_id db . session . commit ()","title":"Select query"},{"location":"alpha_database/#init_1","text":"new_duck = Duck ( \"name\" : name , \"duck_type_id\" : duck_type_id ) db . session . merge ( new_duck ) db . session . commit () or attr = { \"name\" : name , \"duck_type_id\" : duck_type_id , } duck = Duck ( ** attr ) db . session . merge ( new_duck ) db . session . commit ()","title":"Init"},{"location":"alpha_database/#init-and-update","text":"new_duck = Duck () new_duck . name = name new_duck . duck_type_id = duck_type_id db . session . merge ( new_duck ) db . session . commit ()","title":"Init and update"},{"location":"alpha_database/#update_1","text":"Alphaz include a special update method that simplifies updates via api routes","title":"Update"},{"location":"alpha_database/#model-as-a-parameter","text":"Warning This is not recommanded because you could not specified if a field of Duck is required or not @route ( path = 'duck' , methods = [ \"PUT\" ], parameters = [ Parameter ( \"duck\" , ptype = Duck , required = True ) ], ) def update_duck (): return DB . update ( api [ \"duck\" ])","title":"Model as a parameter"},{"location":"alpha_database/#route-parameters-to-model","text":"@route ( path = 'duck' , methods = [ \"PUT\" ], parameters = [ Parameter ( \"name\" , ptype = str , required = True ), Parameter ( \"duck_type_id\" , ptype = int ) ], ) def update_duck (): return DB . update ( Duck ( ** api . get_parameters ()), not_none = True ) # not_none is to set if you dont want None values to update fields or using a function: def update_duck ( name : str , duck_type_id : str ): return DB . update ( Duck ( ** locals ())) @route ( path = 'duck' , methods = [ \"PUT\" ], parameters = [ Parameter ( \"name\" , ptype = str , required = True ), Parameter ( \"duck_type_id\" , ptype = int ) ], ) def update_duck (): return update_duck ( ** api . get_parameters ())","title":"Route parameters to model"},{"location":"alpha_database/#relations","text":"","title":"Relations"},{"location":"alpha_database/#relation-filter","text":"return DB . select ( Duck , filters = [ Duck . duck_type . has ( DuckType . name . like ( name ))] ) Will produce a query like: SELECT * FROM DUCK WHERE EXISTS ( SELECT 1 FROM DUCKTYPE where DUCKTYPE . id == DUCK . ducktype_id and DUCKTYPE . name = name ) Doc","title":"Relation filter"},{"location":"alpha_screens/","text":"Alpha screens system Alpha integrate a simple utility that enable to ensure that a screen if running or not. optional arguments: -h, * --help show this help message and exit --log LOG, -l LOG log file path --file FILE, -f FILE Input configuration file --name NAME, -n NAME Screen name --cmd CMD, -c CMD Command to run --envs ENVS [ENVS ...], -e ENVS [ENVS ...] Command to run --directory DIRECTORY, -d DIRECTORY Working directory --request REQUEST, -req REQUEST Request to check the response --retries RETRIES, -ret RETRIES Number of check before fail state --sleep SLEEP, -s SLEEP Sleep time (s) --timeout TIMEOUT, -t TIMEOUT Sleep time (s) --message MESSAGE, -m MESSAGE Check message --failed_message FAILED_MESSAGE, -fm FAILED_MESSAGE Failed message --success_message SUCCESS_MESSAGE, -sm SUCCESS_MESSAGE Success message --restart, -r Force a restart Launch Easy to launch, two modes are available: Configuration file python -m alphaz.utils.screens -f <config_file_path> The configuration format is the following, it use the dynamic json alpha configuration syntax : { \"screens\" : { \"api\" : { \"active\" : true , \"name\" : \"API\" , \"dir\" : \"{{home}}/{{name}}\" , \"shell_cmd\" : \"python api.py\" , \"request\" : \"http://0.0.0.0:{{port}}/status\" , \"fail_message\" : \"Api failed to restart\" }, \"api\" : { \"active\" : false , \"name\" : \"API\" , \"dir\" : \"{{home}}/{{name}}\" , \"shell_cmd\" : \"python api.py\" , \"request\" : \"http://0.0.0.0:{{port}}/status\" , \"fail_message\" : \"Failed\" } }, \"configurations\" : { \"local\" : { \"port\" : \"auto\" }, \"dev\" : { \"port\" : 3000 }, \"prod\" : { \"port\" : 5000 } }, \"home\" : \"/home/mes\" , \"name\" : \"pyMES\" } Parameters: python -m alphaz.utils.screens * --name TEST * --cmd \"python api.py\" Help python -m alphaz.utils.screens","title":"Screens"},{"location":"alpha_screens/#alpha-screens-system","text":"Alpha integrate a simple utility that enable to ensure that a screen if running or not. optional arguments: -h, * --help show this help message and exit --log LOG, -l LOG log file path --file FILE, -f FILE Input configuration file --name NAME, -n NAME Screen name --cmd CMD, -c CMD Command to run --envs ENVS [ENVS ...], -e ENVS [ENVS ...] Command to run --directory DIRECTORY, -d DIRECTORY Working directory --request REQUEST, -req REQUEST Request to check the response --retries RETRIES, -ret RETRIES Number of check before fail state --sleep SLEEP, -s SLEEP Sleep time (s) --timeout TIMEOUT, -t TIMEOUT Sleep time (s) --message MESSAGE, -m MESSAGE Check message --failed_message FAILED_MESSAGE, -fm FAILED_MESSAGE Failed message --success_message SUCCESS_MESSAGE, -sm SUCCESS_MESSAGE Success message --restart, -r Force a restart","title":"Alpha screens system"},{"location":"alpha_screens/#launch","text":"Easy to launch, two modes are available: Configuration file python -m alphaz.utils.screens -f <config_file_path> The configuration format is the following, it use the dynamic json alpha configuration syntax : { \"screens\" : { \"api\" : { \"active\" : true , \"name\" : \"API\" , \"dir\" : \"{{home}}/{{name}}\" , \"shell_cmd\" : \"python api.py\" , \"request\" : \"http://0.0.0.0:{{port}}/status\" , \"fail_message\" : \"Api failed to restart\" }, \"api\" : { \"active\" : false , \"name\" : \"API\" , \"dir\" : \"{{home}}/{{name}}\" , \"shell_cmd\" : \"python api.py\" , \"request\" : \"http://0.0.0.0:{{port}}/status\" , \"fail_message\" : \"Failed\" } }, \"configurations\" : { \"local\" : { \"port\" : \"auto\" }, \"dev\" : { \"port\" : 3000 }, \"prod\" : { \"port\" : 5000 } }, \"home\" : \"/home/mes\" , \"name\" : \"pyMES\" } Parameters: python -m alphaz.utils.screens * --name TEST * --cmd \"python api.py\"","title":"Launch"},{"location":"alpha_screens/#help","text":"python -m alphaz.utils.screens","title":"Help"},{"location":"alpha_setup/","text":"Alpha system OS configuration Important make sure that Git is well configured. Python Python 3.10.4 is required. Anaconda or Miniconda could be used. There is no constraint but the usual structure is to have: a user per configuration ( mes , mesacc , mesint and mesdev for exemple) three location per user: /home/USER/APP_NAME for sources /home/USER/configs for configurations /application/USER/APP_NAME for tmp files and logs Note This is configured within the conf.json file and could be modified Setup If you just want to use the system go for the classic way and if you want to modify it use the sources integration. Classic The default installation procedure is: pip install alphaz It will install all the dependencies automatically. Using sources If you want to edit the sources you could use this procedure to clone the sources and configure it as a sub module Clone alphaz from the repository https://github.com/ZAurele/alphaz.git cd <your_project_repository> git clone https://github.com/ZAurele/alphaz.git Launch the setup, it will install all the dependencies and other magical actions. python setup.py Define it as a submodule in your project Dependencies Main dependencies are automatically installed, however if you need specific ones, you will have to install them manually Oracle Oracle client Configuration Angular { \"compilerOptions\" : { \"baseUrl\" : \"./src\" , \"paths\" : { \"@services/*\" : [ \"app/services/*\" , \"src/app/services/*\" ], \"@views/*\" : [ \"app/views/*\" , \"src/app/views/*\" ], \"@models/*\" : [ \"app/models/*\" , \"src/app/models/*\" ], \"@components/*\" : [ \"app/components/*\" , \"src/app/components/*\" ], \"@alphaa/*\" : [ \"alphaa/*\" , \"src/alphaa/*\" ], \"@layout/*\" : [ \"app/layout/*\" , \"src/app/layout/*\" ], \"@envs/*\" : [ \"environments/*\" , \"src/environments/*\" ], \"@constants/*\" : [ \"app/constants/*\" , \"src/app/constants/*\" ] } } }","title":"Setup"},{"location":"alpha_setup/#alpha-system","text":"","title":"Alpha system"},{"location":"alpha_setup/#os-configuration","text":"Important make sure that Git is well configured.","title":"OS configuration"},{"location":"alpha_setup/#python","text":"Python 3.10.4 is required. Anaconda or Miniconda could be used. There is no constraint but the usual structure is to have: a user per configuration ( mes , mesacc , mesint and mesdev for exemple) three location per user: /home/USER/APP_NAME for sources /home/USER/configs for configurations /application/USER/APP_NAME for tmp files and logs Note This is configured within the conf.json file and could be modified","title":"Python"},{"location":"alpha_setup/#setup","text":"If you just want to use the system go for the classic way and if you want to modify it use the sources integration.","title":"Setup"},{"location":"alpha_setup/#classic","text":"The default installation procedure is: pip install alphaz It will install all the dependencies automatically.","title":"Classic"},{"location":"alpha_setup/#using-sources","text":"If you want to edit the sources you could use this procedure to clone the sources and configure it as a sub module Clone alphaz from the repository https://github.com/ZAurele/alphaz.git cd <your_project_repository> git clone https://github.com/ZAurele/alphaz.git Launch the setup, it will install all the dependencies and other magical actions. python setup.py Define it as a submodule in your project","title":"Using sources"},{"location":"alpha_setup/#dependencies","text":"Main dependencies are automatically installed, however if you need specific ones, you will have to install them manually","title":"Dependencies"},{"location":"alpha_setup/#oracle","text":"Oracle client","title":"Oracle"},{"location":"alpha_setup/#configuration","text":"","title":"Configuration"},{"location":"alpha_setup/#angular","text":"{ \"compilerOptions\" : { \"baseUrl\" : \"./src\" , \"paths\" : { \"@services/*\" : [ \"app/services/*\" , \"src/app/services/*\" ], \"@views/*\" : [ \"app/views/*\" , \"src/app/views/*\" ], \"@models/*\" : [ \"app/models/*\" , \"src/app/models/*\" ], \"@components/*\" : [ \"app/components/*\" , \"src/app/components/*\" ], \"@alphaa/*\" : [ \"alphaa/*\" , \"src/alphaa/*\" ], \"@layout/*\" : [ \"app/layout/*\" , \"src/app/layout/*\" ], \"@envs/*\" : [ \"environments/*\" , \"src/environments/*\" ], \"@constants/*\" : [ \"app/constants/*\" , \"src/app/constants/*\" ] } } }","title":"Angular"},{"location":"documentation/","text":"Documentation Requirements install packages pip install pymdown-extensions pygments mkdocs-material Add extensions in mkdocs.yaml markdown_extensions: - admonition - pymdownx.arithmatex - pymdownx.details - codehilite - pymdownx.superfences More for more information","title":"Documentation"},{"location":"documentation/#documentation","text":"","title":"Documentation"},{"location":"documentation/#requirements","text":"install packages pip install pymdown-extensions pygments mkdocs-material Add extensions in mkdocs.yaml markdown_extensions: - admonition - pymdownx.arithmatex - pymdownx.details - codehilite - pymdownx.superfences","title":"Requirements"},{"location":"documentation/#more","text":"for more information","title":"More"}]}